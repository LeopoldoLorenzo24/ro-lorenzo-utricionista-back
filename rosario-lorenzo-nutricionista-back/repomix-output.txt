This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
main.py
turnos.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Ignorar el archivo de variables sensibles
.env

# Ignorar entorno virtual
venv/
.venv/

# Ignorar archivos temporales y de Python
__pycache__/
*.pyc
*.pyo
*.pyd

# Archivos de configuración del editor
.vscode/
</file>

<file path="main.py">
from fastapi import FastAPI, HTTPException, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import mercadopago
import os
import json
import uuid
from datetime import datetime, timedelta
from dotenv import load_dotenv
import urllib.parse
from typing import Optional 

load_dotenv()

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://ro-lorenzo-nutricionista.onrender.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

sdk = mercadopago.SDK(os.getenv("MP_ACCESS_TOKEN"))
FRONT_URL = os.getenv("FRONT_URL", "https://ro-lorenzo-nutricionista.onrender.com")
WEBHOOK_URL = os.getenv("WEBHOOK_URL", "https://ro-lorenzo-nutricionista-back.onrender.com/webhook")


def limpiar_turnos_vencidos(turnos):
    ahora = datetime.now()
    filtrados = []
    for turno in turnos:
        if turno["estado"] == "pendiente_de_pago":
            fecha_creacion = datetime.fromisoformat(turno["fecha_creacion"])
            if ahora - fecha_creacion < timedelta(minutes=1):  # Para pruebas, luego cambiar a hours=12
                filtrados.append(turno)
        else:
            filtrados.append(turno)
    return filtrados


class TurnoRequest(BaseModel):
    nombre: str
    apellido: str
    motivo: str
    modalidad: str
    fecha: str
    hora: str
    duracion: str
    costo: float
    ubicacion: str


@app.post("/crear-preferencia")
def crear_preferencia(turno: TurnoRequest):
    print("\n--- [INFO] Endpoint /crear-preferencia alcanzado. ---")

    try:
        with open("turnos.json", "r", encoding="utf-8") as f:
            turnos = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        turnos = []

    turnos = limpiar_turnos_vencidos(turnos)

    turno_id = str(uuid.uuid4())
    token_cancelacion = str(uuid.uuid4())

    turno_data = {
        "id": turno_id,
        "estado": "pendiente_de_pago",
        "nombre": turno.nombre,
        "apellido": turno.apellido,
        "motivo": turno.motivo,
        "modalidad": turno.modalidad,
        "fecha": turno.fecha,
        "hora": turno.hora,
        "duracion": turno.duracion,
        "costo": turno.costo,
        "ubicacion": turno.ubicacion,
        "token_cancelacion": token_cancelacion,
        "fecha_creacion": datetime.now().isoformat()
    }

    turnos.append(turno_data)
    with open("turnos.json", "w", encoding="utf-8") as f:
        json.dump(turnos, f, indent=2, ensure_ascii=False)

    query_string = urllib.parse.urlencode({
        "nombre": turno.nombre,
        "apellido": turno.apellido,
        "motivo": turno.motivo,
        "modalidad": turno.modalidad,
        "fecha": turno.fecha,
        "hora": turno.hora,
        "ubicacion": turno.ubicacion,
    })

    preference_data = {
        "items": [
            {
                "title": f"Turno - {turno.motivo}",
                "quantity": 1,
                "unit_price": float(turno.costo),
                "currency_id": "ARS"
            }
        ],
        "external_reference": turno_id,
        "notification_url": WEBHOOK_URL,
        "payment_methods": {
            "excluded_payment_types": [{"id": "atm"}],  # ⚠️ ticket (efectivo) está PERMITIDO
            "installments": 1
        },
        "back_urls": {
            "success": f"{FRONT_URL}/gracias?{query_string}",
            "failure": f"{FRONT_URL}/error?id={turno_id}",
            "pending": f"{FRONT_URL}/pending"
        },
        "auto_return": "approved"
    }

    try:
        preference_response = sdk.preference().create(preference_data)
        if "init_point" not in preference_response["response"]:
            raise ValueError("init_point no recibido de Mercado Pago")
        init_point = preference_response["response"]["init_point"]
        return {"pago_url": init_point}
    except Exception as e:
        print("[ERROR] al crear preferencia:", e)
        raise HTTPException(status_code=500, detail="Error al crear preferencia de pago.")


@app.post("/webhook")
async def recibir_webhook(request: Request):
    try:
        body = await request.json()
        if body.get("type") != "payment":
            return {"status": "ignorado"}

        payment_id = body.get("data", {}).get("id")
        if not payment_id:
            return {"status": "sin id de pago"}

        payment_info = sdk.payment().get(payment_id)
        status = payment_info["response"].get("status")
        external_reference = payment_info["response"].get("external_reference")

        if status == "approved":
            with open("turnos.json", "r+", encoding="utf-8") as f:
                turnos = json.load(f)
                for turno in turnos:
                    if turno["id"] == external_reference:
                        turno["estado"] = "confirmado"
                        break
                f.seek(0)
                json.dump(turnos, f, indent=2, ensure_ascii=False)
                f.truncate()
        return {"status": "ok"}

    except Exception as e:
        print(f"[ERROR] en webhook: {e}")
        return {"status": "error"}


@app.get("/turnos-ocupados")
def turnos_ocupados(modalidad: str = Query(...), fecha: str = Query(...)):
    try:
        with open("turnos.json", "r", encoding="utf-8") as f:
            turnos = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        turnos = []

    turnos = limpiar_turnos_vencidos(turnos)

    with open("turnos.json", "w", encoding="utf-8") as f:
        json.dump(turnos, f, indent=2, ensure_ascii=False)

    horarios_ocupados = [
        turno["hora"]
        for turno in turnos
        if turno["modalidad"].lower() == modalidad.lower()
        and turno["fecha"] == fecha
        and turno["estado"] == "confirmado"
    ]
    return horarios_ocupados


@app.delete("/cancelar-turno")
def cancelar_turno(id: str):
    try:
        with open("turnos.json", "r", encoding="utf-8") as f:
            turnos = json.load(f)
        nuevos_turnos = [t for t in turnos if t["id"] != id]
        with open("turnos.json", "w", encoding="utf-8") as f:
            json.dump(nuevos_turnos, f, indent=2, ensure_ascii=False)
        return {"status": "turno cancelado"}
    except Exception as e:
        print(f"[ERROR] No se pudo cancelar el turno: {e}")
        raise HTTPException(500, "No se pudo cancelar el turno")

@app.get("/ver-turnos")
def ver_turnos(estado: Optional[str] = Query(None)):
    """
    Devuelve todos los turnos.
    Si se pasa ?estado=confirmado o ?estado=pendiente_de_pago, los filtra.
    """
    try:
        with open("turnos.json", "r", encoding="utf-8") as f:
            turnos = json.load(f)

        # Aplicar limpieza de vencidos
        turnos = limpiar_turnos_vencidos(turnos)

        if estado:
            turnos = [t for t in turnos if t["estado"] == estado]

        return {"turnos": turnos}

    except Exception as e:
        print(f"[ERROR] No se pudieron leer los turnos: {e}")
        raise HTTPException(status_code=500, detail="No se pudieron leer los turnos")

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("main:app", host="0.0.0.0", port=port)
</file>

<file path="turnos.json">
[
  {
    "id": "a492cca9-39a2-4951-8381-4c863528b758",
    "estado": "pendiente_de_pago",
    "nombre": "Leopoldo",
    "apellido": "Lorenzo",
    "motivo": "Antropometría",
    "modalidad": "virtual",
    "fecha": "2025-07-31",
    "hora": "15:00",
    "duracion": "15 minutos",
    "costo": 1.0,
    "ubicacion": "Online",
    "token_cancelacion": "b7cfede8-fd46-4af6-9b68-5d01ced25915",
    "fecha_creacion": "2025-07-31T13:25:46.011213"
  },
  {
    "id": "0a90a092-f40b-41bf-b52a-bd626bc719b3",
    "estado": "pendiente_de_pago",
    "nombre": "Leopoldo",
    "apellido": "Lorenzo",
    "motivo": "Antropometría",
    "modalidad": "virtual",
    "fecha": "2025-07-31",
    "hora": "15:00",
    "duracion": "15 minutos",
    "costo": 1.0,
    "ubicacion": "Online",
    "token_cancelacion": "884e6f7f-73fb-4646-9dfe-d2a0b0c987ef",
    "fecha_creacion": "2025-07-31T13:27:54.194468"
  },
  {
    "id": "7fb5f92e-3659-4760-9bf8-26abbb617a56",
    "estado": "pendiente_de_pago",
    "nombre": "Leopoldo",
    "apellido": "Lorenzo",
    "motivo": "Antropometría",
    "modalidad": "virtual",
    "fecha": "2025-07-31",
    "hora": "15:00",
    "duracion": "15 minutos",
    "costo": 1.0,
    "ubicacion": "Online",
    "token_cancelacion": "16884f30-17bb-46c0-acc3-827765185b78",
    "fecha_creacion": "2025-07-31T13:29:53.379266"
  },
  {
    "id": "c7af2b03-2ead-419d-baff-73d91e98737d",
    "estado": "pendiente_de_pago",
    "nombre": "Leopoldo",
    "apellido": "Lorenzo",
    "motivo": "Antropometría",
    "modalidad": "virtual",
    "fecha": "2025-07-31",
    "hora": "15:00",
    "duracion": "15 minutos",
    "costo": 1.0,
    "ubicacion": "Online",
    "token_cancelacion": "8127e53a-5634-4a0d-b551-e8e95245f7d0",
    "fecha_creacion": "2025-07-31T13:33:57.550937"
  }
]
</file>

</files>
